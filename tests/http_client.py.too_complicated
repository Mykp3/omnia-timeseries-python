from typing import Literal, Optional, TypedDict, Union, Dict, Any
from azure.identity._internal.msal_credentials import MsalCredential
import requests
import logging
from azure.identity import ManagedIdentityCredential
import os


from omnia_timeseries.helpers import retry
from omnia_timeseries.models import TimeseriesRequestFailedException
from importlib import metadata
from opentelemetry.instrumentation.requests import RequestsInstrumentor
import platform

ENDPOINTS = {
    "azureml": "https://management.azure.com/.default",
    "graph": "https://graph.microsoft.com/.default",
    "storage": "https://storage.azure.com/.default",
    "default": "https://management.azure.com/.default"
}


ContentType = Literal["application/json",
                      "application/protobuf", "application/x-google-protobuf"]

RequestType = Literal['get', 'put', 'post', 'patch', 'delete']

CLIENT_ID = os.getenv("AZURE_CLIENT_ID")
credential = ManagedIdentityCredential(client_id=CLIENT_ID)

logger = logging.getLogger(__name__)
version = metadata.version("omnia_timeseries")
system_version_string = f'({platform.system()}; Python {platform.version()})' if platform.system(
) else f'(Python {platform.version()})'

RequestsInstrumentor().instrument()

@retry(logger=logger)
def _request(
    request_type: RequestType,
    url: str,
    headers: Dict[str, Any],
    payload: Optional[Union[TypedDict, dict, list]] = None,
    params: Optional[Dict[str, Any]] = None
) -> Union[Dict[str, Any], bytes]:

    response = requests.request(
        request_type, url, headers=headers, json=payload, params=params)
    if not response.ok:
        raise TimeseriesRequestFailedException(response)
    if not "Accept" in headers or headers["Accept"] == "application/json":
        return response.json()
    else:
        return response.content

class AzureAuthenticator:
    def __init__(self, azure_credential: MsalCredential):
        self._azure_credential = azure_credential
        self._token_cache = {}

    def get_token(self, resource: str) -> str:

        if resource not in self._token_cache:
            token = self._azure_credential.get_token(resource)
            self._token_cache[resource] = token
        return self._token_cache[resource]

    def resolve_endpoint(self, url: str, service_name: Optional[str] = None) -> str:
        if service_name:
            return ENDPOINTS.get(service_name, ENDPOINTS["default"])
        
        if "azureml" in url.lower():
            return ENDPOINTS["azureml"]
        elif "graph.microsoft.com" in url.lower():
            return ENDPOINTS["graph"]
        elif "storage" in url.lower():
            return ENDPOINTS["storage"]
        
        # Default fallback
        return ENDPOINTS["default"]


class HttpClient:
    def __init__(self, azure_authenticator: AzureAuthenticator):
        self._authenticator = azure_authenticator

    def request(
        self,
        request_type: RequestType,
        url: str,
        service_name: Optional[str] = None,
        accept: ContentType = "application/json",
        payload: Optional[Union[TypedDict, dict, list]] = None,
        params: Optional[Dict[str, Any]] = None
    ) -> Any:

        # Resolve the correct endpoint
        auth_endpoint = self._authenticator.resolve_endpoint(url, service_name)

        # Get the token for the resolved endpoint
        access_token = self._authenticator.get_token(auth_endpoint)

        headers = {
            'Authorization': f'Bearer {access_token.token}',
            'Content-Type': 'application/json',
            'Accept': accept,
            'User-Agent': f'Omnia Timeseries SDK/{version} {system_version_string}'
        }

        print(f"Using Endpoint: {auth_endpoint}")
        print(f"Access Token: {access_token.token}")

        return _request(request_type=request_type, url=url, headers=headers, payload=payload, params=params)
